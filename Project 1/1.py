

import yfinance as yf
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
import numpy as np
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, mean_absolute_error
from sklearn.model_selection import train_test_split
import mplfinance as mpf
from matplotlib.pyplot import legend


# This is the symbol and range value:::::
symbol = "META"
start_date = "2025-01-01"
end_date = "2025-08-22"

# Add retry + cache to handle rate limits / empty downloads
import os
import time
import sys
import random
import io
import contextlib
import warnings

cache_file = f"{symbol}_{start_date}_{end_date}.csv"

def _silent_yf_download(ticker, start, end):
    with warnings.catch_warnings():
        warnings.simplefilter("ignore")
        f_stdout, f_stderr = io.StringIO(), io.StringIO()
        with contextlib.redirect_stdout(f_stdout), contextlib.redirect_stderr(f_stderr):
            df = yf.download(ticker, start=start, end=end, auto_adjust=False, progress=False, threads=False)
    return df

def _silent_yf_ticker_history(ticker, start, end):
    with warnings.catch_warnings():
        warnings.simplefilter("ignore")
        f_stdout, f_stderr = io.StringIO(), io.StringIO()
        with contextlib.redirect_stdout(f_stdout), contextlib.redirect_stderr(f_stderr):
            t = yf.Ticker(ticker)
            df = t.history(start=start, end=end, auto_adjust=False)
    return df

def fetch_history_with_retry(ticker, start, end, max_retries=10):
    last_err = None
    for attempt in range(max_retries):
        try:
            df = _silent_yf_download(ticker, start, end)
            if df is not None and not df.empty:
                return df
            # try alternate path
            df2 = _silent_yf_ticker_history(ticker, start, end)
            if df2 is not None and not df2.empty:
                return df2
        except Exception as e:
            last_err = e
        # exponential backoff with jitter
        sleep_s = min(2 ** attempt, 300) + random.uniform(0, 1.0)
        time.sleep(sleep_s)
    if last_err:
        raise RuntimeError(f"Failed to download data for {ticker}: {last_err}")
    raise RuntimeError(f"Failed to download data for {ticker}: Empty response after retries")

# Code to Download historical data::::::
if os.path.exists(cache_file):
    try:
        meta_data = pd.read_csv(cache_file, index_col=0, parse_dates=True)
    except Exception:
        meta_data = None
else:
    meta_data = None

if meta_data is None or meta_data.empty:
    try:
        meta_data = fetch_history_with_retry(symbol, start_date, end_date)
        if meta_data is not None and not meta_data.empty:
            meta_data.to_csv(cache_file)
    except Exception as e:
        print(f"Error fetching data: {e}")
        if meta_data is None or meta_data.empty:
            print("No cached data available. Please try again later or adjust the date range.")
            sys.exit(1)

# Guard against empty dataset
if meta_data is None or meta_data.empty:
    print("No data retrieved for the given symbol/date range. Please try again later or adjust the range.")
    sys.exit(1)

# THIS code Fills the missing values with the average of existing data:::::::::

meta_data.fillna(meta_data.mean(numeric_only=True), inplace=True)
# The inplace=True updates the DataFrame directly.

# Features required to predict and analyse::::::

features = ['Open', 'High', 'Low', 'Volume']
# using indexing and slicing

# Code to conduct Train-test split::::

X_train, X_test, y_train, y_test = train_test_split(meta_data[features], meta_data['Close'], test_size=0.2,random_state=116)
# y_test: This represents the actual target values for testing
# y_train: This represents the actual target values for training
# X_train: The features for training
# X_test: The features for testing

# Building and training linear regression mode::::
model = LinearRegression()
model.fit(X_train, y_train)

# Evaluation of the model::::
y_pred = model.predict(X_test)
mse = mean_squared_error(y_test, y_pred)
mae = mean_absolute_error(y_test, y_pred)
rmse = mean_squared_error(y_test, y_pred, squared=False)
# y_test: This represents the actual target values
# y_pred: This represents the predicted target values generated by regression model
# false because it will return root of mse or else it will give mse directly

# Printing the evaluated values with 1 decimal place::::::
print(f"Mean Squared Error (MSE): {mse:.1f}")
print(f"Mean Absolute Error (MAE): {mae:.1f}")
print(f"Root Mean Squared Error (RMSE): {rmse:.1f}")

# Code for Calculating Bollinger Bands::::

window = 20
# this represents number of data points used to calculate moving averages

meta_data['SMA'] = meta_data['Close'].rolling(window=window).mean()
# here SMA = simple moving average
# close refers to closing price of stock
# .mean() claculates SMA over rolling window for closing prices
# rolling window is created of size 20

meta_data['Upper'] = meta_data['SMA'] + 2 * meta_data['Close'].rolling(window=window).std()
# here we do [SMA + 2*] the rolling STD to get upper band

meta_data['Lower'] = meta_data['SMA'] - 2 * meta_data['Close'].rolling(window=window).std()
# here we do [SMA - 2*] the rolling STD to get the lower band

# these bands help visualize potential overbought or oversold conditions in the stockprice
# it means when the prices moves close to the upper band it may be overbought
# and when it approaches lower band it may be oversold
# traders use this to identify potential price reversals or volatility changes

# Code to Extract the latest data ::::::

latest_data = meta_data.iloc[-1]
# The variable latest_data now holds the data for the most recent day (today) in the historical stock data.
# meta_data.iloc[-1] selects the entire last row (latest data) from the DataFrame

# Code to Predict tomorrow's closing price:::::::

predicted_tomorrow_price = model.predict([[latest_data['Open'], latest_data['High'], latest_data['Low'], latest_data['Volume']]])[0]
# model refers to the trained linear regression model
# predict() is a method of the model that predicts the target variable (the closing price) based on input features
# The input features are provided as a 2D array , Each inner array contains the feature values for a single data point
# latest_data['Open']: The opening price for the latest trading day
# latest_data['Low']: The lowest price during the latest trading day
# latest_data['Volume']: The trading volume during the latest trading day
# The predict() method returns an array of predicted values (in this case a single value is given for tomorrow’s closing price)
# we use [0] to extract the first element from that array

# Printing predicted closing price with 2 decimals ::::::
print(f"Predicted closing price for tomorrow: ${predicted_tomorrow_price:.2f}")

# Creates a single plot:::::::
plt.figure(figsize=(16, 8))

# This code Plots actual closing prices and predicted prices:::::::

plt.plot(meta_data.index, meta_data['Close'], color='red', label='Actual Price')
# This line plots the actual closing prices (meta_data['Close']) against the date index (meta_data.index)

plt.plot(meta_data.index, model.predict(meta_data[features]), color='blue', label='Predicted Price')
# This line plots the predicted closing prices (based on the trained linear regression model) against the date index

plt.bar(meta_data.index, meta_data['Volume'] / 1e6, alpha=0.9, color='green', label='Volume (Millions)')
# This line creates a bar graph for the trading volume (meta_data['Volume']) against the date index
# The volume values are divided by 1 million (/ 1e6) to make the bars more visually understandable

# This Plots Bollinger Bands:::::::::

plt.plot(meta_data.index, meta_data['Upper'], color='magenta', linestyle='--', label='Upper Bollinger Band')
# This line plots the upper Bollinger Band against the date index

plt.plot(meta_data.index, meta_data['Lower'], color='cyan', linestyle='--', label='Lower Bollinger Band')
# this line plots the lower Bollinger Band against the date index

plt.plot(meta_data.index, meta_data['SMA'], color='orange', linestyle='-', label='Simple Moving Average (SMA)')
# This line plots the Simple Moving Average (SMA) against the date index

# This code is for labeling:::::::
plt.xlabel('Date')
plt.ylabel('Price (USD)')
plt.title('Meta Stock Price Predictions (2024) with Bollinger Bands')
plt.ylim(0,600)
plt.legend()
plt.grid(True)
plt.show()

# this plots candlestick graph::::::

mav_tuple = (5, 20)
# These represent the periods for the moving averages

mav_titles = ['5-day MA', '20-day MA']
# contains the titles for the moving averages: ‘5-day MA’ and ‘20-day MA

fig, axes = mpf.plot(meta_data, type='candle', mav=mav_tuple, volume=True,
                     title='META Stock Price with Technical Indicators',
                     style='yahoo', returnfig=True)

# The mpf.plot() function is used to create a candlestick chart for the stock data stored in meta_data
# The type='candle' specifies that we want a candlestick chart
# The 'mav' argument specifies the moving averages to be plotted on the chart
# The volume=True argument indicates that we want to include volume bars on the chart
# The style='yahoo' argument specifies the style of the chart
# The returnfig=True argument returns the figure and axes objects

for ax in axes:
    ax.legend(mav_titles)
# for ax in axes: loop iterates over each subplot (axes) in the figure
# ax.legend(mav_titles) line adds legends to each subplot, displaying the moving average titles

print(meta_data)
meta_data
meta_data.describe()


